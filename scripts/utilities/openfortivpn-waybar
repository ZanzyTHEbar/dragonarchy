#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
DOTFILES_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
# shellcheck disable=SC1091
source "$DOTFILES_ROOT/scripts/lib/notifications.sh"

HOST_SHORT="$(hostname | cut -d. -f1)"
DEFAULT_ENABLE_FILE="$HOME/.config/waybar-hosts/$HOST_SHORT/vpn-enabled"
ENABLE_FILE="${OPENFORTIVPN_WAYBAR_ENABLE_FILE:-$DEFAULT_ENABLE_FILE}"
VPN_IFACE="${OPENFORTIVPN_IFACE:-ppp0}"
VPN_CONFIG="${OPENFORTIVPN_CONFIG:-/etc/openfortivpn/config}"
VPN_CMD="${OPENFORTIVPN_CMD:-openfortivpn}"
VPN_PROC_NAME="${OPENFORTIVPN_PROC_NAME:-${VPN_CMD##*/}}"
SUDO_CMD="${OPENFORTIVPN_SUDO_CMD:-sudo}"
SAML_PORT_DEFAULT="${OPENFORTIVPN_SAML_PORT:-8020}"

have_cmd() { command -v "$1" >/dev/null 2>&1; }

systemd_service_exists() {
  have_cmd systemctl || return 1
  systemctl list-unit-files --type=service 2>/dev/null | grep -q '^openfortivpn\.service'
}

systemd_is_active() {
  have_cmd systemctl || return 1
  systemctl is-active --quiet openfortivpn.service
}

systemd_start_vpn() {
  systemctl start openfortivpn.service
}

systemd_stop_vpn() {
  systemctl stop openfortivpn.service
  systemctl reset-failed openfortivpn.service >/dev/null 2>&1 || true
}

systemd_cleanup_exists() {
  have_cmd systemctl || return 1
  systemctl list-unit-files --type=service 2>/dev/null | grep -q '^openfortivpn-cleanup\.service'
}

systemd_cleanup_vpn() {
  systemctl start openfortivpn-cleanup.service
}

systemd_main_pid() {
  have_cmd systemctl || return 1
  systemctl show -p MainPID --value openfortivpn.service 2>/dev/null || true
}

openfortivpn_pids() {
  pgrep -x "$VPN_PROC_NAME" 2>/dev/null || true
}

stray_openfortivpn_pids() {
  local main_pid=""
  main_pid="$(systemd_main_pid)"
  local pid
  for pid in $(openfortivpn_pids); do
    if [[ -n "$main_pid" && "$main_pid" != "0" && "$pid" == "$main_pid" ]]; then
      continue
    fi
    echo "$pid"
  done
}

stray_openfortivpn_running() {
  [[ -n "$(stray_openfortivpn_pids)" ]]
}

port_in_use() {
  local port="$1"
  if have_cmd ss; then
    ss -ltn "sport = :$port" 2>/dev/null | awk 'NR>1 {print $1; exit}' | grep -q LISTEN
    return $?
  fi
  if have_cmd netstat; then
    netstat -ltn 2>/dev/null | awk -v p=":$port" '$4 ~ p {print $6; exit}' | grep -q LISTEN
    return $?
  fi
  return 1
}

wait_for_port() {
  local port="$1"
  local max_wait_ms="${2:-5000}"
  local slept=0
  local step=200
  while (( slept < max_wait_ms )); do
    if port_in_use "$port"; then
      return 0
    fi
    sleep 0.2
    slept=$((slept + step))
  done
  return 1
}

wait_for_disconnect() {
  local max_wait_ms="${1:-6000}"
  local slept=0
  local step=300
  while (( slept < max_wait_ms )); do
    if ! vpn_iface_up && ! vpn_proc_running && !(systemd_service_exists && systemd_is_active); then
      return 0
    fi
    sleep 0.3
    slept=$((slept + step))
  done
  return 1
}

force_disconnect_root() {
  local iface="${VPN_IFACE}"
  if have_cmd "$SUDO_CMD" && "$SUDO_CMD" -n true >/dev/null 2>&1; then
    "$SUDO_CMD" -n bash -lc "
      pkill -INT openfortivpn 2>/dev/null || true
      sleep 1
      pkill -TERM openfortivpn 2>/dev/null || true
      sleep 1
      pkill -KILL openfortivpn 2>/dev/null || true
      pkill -TERM pppd 2>/dev/null || true
      pkill -KILL pppd 2>/dev/null || true
      ip link set \"$iface\" down 2>/dev/null || true
    " >/dev/null 2>&1
    return 0
  fi

  if have_cmd pkexec; then
    pkexec bash -lc "
      pkill -INT openfortivpn 2>/dev/null || true
      sleep 1
      pkill -TERM openfortivpn 2>/dev/null || true
      sleep 1
      pkill -KILL openfortivpn 2>/dev/null || true
      pkill -TERM pppd 2>/dev/null || true
      pkill -KILL pppd 2>/dev/null || true
      ip link set \"$iface\" down 2>/dev/null || true
    " >/dev/null 2>&1
    return 0
  fi

  return 1
}

json_escape() {
  local value="$1"
  value=${value//\\/\\\\}
  value=${value//\"/\\\"}
  value=${value//$'\n'/\\n}
  printf "%s" "$value"
}

notify() {
  local title="$1"
  local body="${2:-}"
  notify_send --app "VPN" "$title" "$body"
}

open_url() {
  local url="$1"
  if have_cmd xdg-open; then
    xdg-open "$url" >/dev/null 2>&1 || true
    return 0
  fi
  if have_cmd gio; then
    gio open "$url" >/dev/null 2>&1 || true
    return 0
  fi
  return 1
}

notify_action_open_url() {
  local url="$1"
  (
    local action=""
    action="$(notify_send --app "VPN" \
      --action "open=Open Login" \
      --action "copy=Copy Link" \
      --wait \
      -- "VPN Login" "Click to open SAML login" || true)"
    case "$action" in
      open)
        open_url "$url"
        ;;
      copy)
        if have_cmd wl-copy; then
          printf "%s" "$url" | wl-copy
        elif have_cmd xclip; then
          printf "%s" "$url" | xclip -selection clipboard
        fi
        ;;
      *)
        notify_send --app "VPN" -- "VPN Login" "Open this URL: $url" >/dev/null 2>&1 || true
        ;;
    esac
  ) &
  disown || true
  return 0
}

enabled() { [[ -f "$ENABLE_FILE" ]]; }

config_value() {
  local key="$1"
  [[ -f "$VPN_CONFIG" && -r "$VPN_CONFIG" ]] || return 0
  awk -F= -v key="$key" '
    /^[[:space:]]*#/ { next }
    /^[[:space:]]*$/ { next }
    $1 ~ "^[[:space:]]*"key"[[:space:]]*$" {
      val=$2
      sub(/^[[:space:]]+/, "", val)
      sub(/[[:space:]]+$/, "", val)
      print val
      exit
    }
  ' "$VPN_CONFIG"
}

vpn_iface_up() {
  have_cmd ip || return 1
  ip link show dev "$VPN_IFACE" >/dev/null 2>&1
}

vpn_addr() {
  have_cmd ip || return 0
  local output=""
  output="$(ip -brief addr show dev "$VPN_IFACE" 2>/dev/null || true)"
  printf "%s" "$output" | awk 'NR==1 {print $3}' | cut -d/ -f1
}

vpn_proc_running() {
  pgrep -x "$VPN_PROC_NAME" >/dev/null 2>&1
}

vpn_state() {
  if vpn_iface_up; then
    echo "connected"
  elif systemd_service_exists; then
    if systemd_is_active; then
      echo "connecting"
    elif stray_openfortivpn_running; then
      echo "error"
    elif vpn_proc_running; then
      echo "error"
    else
      echo "disconnected"
    fi
  elif vpn_proc_running; then
    echo "connecting"
  else
    echo "disconnected"
  fi
}

config_or_default() {
  local key="$1"
  local default="$2"
  local value=""
  value="$(config_value "$key")"
  if [[ -n "$value" ]]; then
    echo "$value"
  else
    echo "$default"
  fi
}

vpn_login_url() {
  local host port
  host="$(config_value host)"
  port="$(config_or_default port 443)"
  if [[ -z "$host" ]]; then
    host="${OPENFORTIVPN_HOST:-}"
  fi
  [[ -z "$host" ]] && return 1
  echo "https://${host}:${port}/remote/saml/start?redirect=1"
}

run_background() {
  if have_cmd setsid; then
    setsid "$@" </dev/null >/tmp/openfortivpn.log 2>&1 &
  else
    "$@" </dev/null >/tmp/openfortivpn.log 2>&1 &
  fi
  disown || true
}

build_cmd_string() {
  local out="" part
  for part in "$@"; do
    out+="$(printf '%q' "$part") "
  done
  printf "%s" "${out% }"
}

launch_terminal() {
  local cmd_string="$1"
  local -a term=()

  if have_cmd kitty; then
    term=(kitty --class=OpenFortiVPN --title=OpenFortiVPN)
  elif have_cmd foot; then
    term=(foot -a OpenFortiVPN)
  elif have_cmd alacritty; then
    term=(alacritty --class OpenFortiVPN,OpenFortiVPN)
  elif have_cmd wezterm; then
    term=(wezterm start --class OpenFortiVPN)
  elif have_cmd gnome-terminal; then
    term=(gnome-terminal --)
  elif have_cmd xterm; then
    term=(xterm -T OpenFortiVPN)
  fi

  if [[ ${#term[@]} -eq 0 ]]; then
    notify "VPN" "No terminal found to launch OpenFortiVPN."
    return 1
  fi

  if have_cmd uwsm && uwsm check is-active >/dev/null 2>&1; then
    uwsm app -- "${term[@]}" bash -lc "$cmd_string" &
  else
    "${term[@]}" bash -lc "$cmd_string" &
  fi
  disown || true
}

status_json() {
  if ! enabled; then
    echo '{"text":"","alt":"","tooltip":"","class":"hidden"}'
    return 0
  fi

  if ! have_cmd "$VPN_CMD"; then
    echo '{"text":"","alt":"error","tooltip":"openfortivpn not found","class":"error"}'
    return 0
  fi

  if [[ -f "$VPN_CONFIG" && ! -r "$VPN_CONFIG" ]]; then
    echo "{\"text\":\"\",\"alt\":\"error\",\"tooltip\":\"$(json_escape "Permission denied reading: $VPN_CONFIG")\",\"class\":\"error\"}"
    return 0
  fi

  if [[ ! -f "$VPN_CONFIG" ]]; then
    echo "{\"text\":\"\",\"alt\":\"error\",\"tooltip\":\"$(json_escape "Missing config: $VPN_CONFIG")\",\"class\":\"error\"}"
    return 0
  fi

  local state tooltip host addr
  state="$(vpn_state)"
  host="$(config_value host)"
  addr="$(vpn_addr)"

  case "$state" in
    connected)
      tooltip="VPN: connected"
      ;;
    connecting)
      tooltip="VPN: connecting"
      ;;
    *)
      tooltip="VPN: disconnected"
      ;;
  esac

  if [[ -n "$host" ]]; then
    tooltip="${tooltip}"$'\n'"Host: ${host}"
  fi
  if [[ -n "$addr" && "$state" == "connected" ]]; then
    tooltip="${tooltip}"$'\n'"IP: ${addr}"
  fi

  tooltip="${tooltip}"$'\n'"Left: toggle | Middle: connect | Right: disconnect"
  if [[ "$state" == "error" ]]; then
    tooltip="${tooltip}"$'\n'"Stray OpenFortiVPN process detected; click to disconnect"
  fi

  echo "{\"text\":\"\",\"alt\":\"$(json_escape "$state")\",\"tooltip\":\"$(json_escape "$tooltip")\",\"class\":\"$(json_escape "$state")\"}"
}

connect_vpn() {
  if ! enabled; then
    notify "VPN" "VPN widget disabled on this host."
    return 0
  fi

  local state
  state="$(vpn_state)"
  if [[ "$state" == "connected" ]]; then
    notify "VPN" "Already connected."
    return 0
  fi
  if [[ "$state" == "connecting" ]]; then
    notify "VPN" "Already connecting."
    return 0
  fi

  if ! have_cmd "$VPN_CMD"; then
    notify "VPN" "openfortivpn not found."
    return 1
  fi
  if [[ ! -f "$VPN_CONFIG" ]]; then
    notify "VPN" "Missing config: $VPN_CONFIG"
    return 1
  fi

  local saml_port url config_path
  saml_port="$SAML_PORT_DEFAULT"
  url="$(vpn_login_url || true)"
  config_path="$VPN_CONFIG"
  if systemd_service_exists && [[ -f /etc/openfortivpn/waybar.conf ]]; then
    config_path="/etc/openfortivpn/waybar.conf"
  fi
  local -a cmd=("$VPN_CMD" "--config" "$config_path" "--saml-login=$saml_port")
  if [[ -n "${OPENFORTIVPN_EXTRA_ARGS:-}" ]]; then
    read -r -a extra <<<"${OPENFORTIVPN_EXTRA_ARGS}"
    cmd+=("${extra[@]}")
  fi

  if port_in_use "$saml_port"; then
    notify "VPN" "Port ${saml_port} is already in use. Stop the listener and retry."
    return 1
  fi

  if systemd_service_exists; then
    if systemd_is_active; then
      notify "VPN" "OpenFortiVPN is already running."
      return 0
    fi
    if stray_openfortivpn_running; then
      notify "VPN" "Stray OpenFortiVPN process detected; cleaning up."
      if systemd_cleanup_exists; then
        systemd_cleanup_vpn || true
      else
        force_disconnect_root || true
      fi
      wait_for_disconnect 5000 || true
    fi
    notify "VPN" "Starting OpenFortiVPN (auth prompt may appear)..."
    if ! systemd_start_vpn; then
      notify "VPN" "Failed to start OpenFortiVPN (check polkit prompt)."
      return 1
    fi
  elif have_cmd "$SUDO_CMD" && "$SUDO_CMD" -n true >/dev/null 2>&1; then
    notify "VPN" "Starting OpenFortiVPN in background..."
    run_background "$SUDO_CMD" -n "${cmd[@]}"
  elif have_cmd pkexec; then
    notify "VPN" "Starting OpenFortiVPN (polkit prompt may appear)..."
    run_background pkexec "${cmd[@]}"
  else
    notify "VPN" "Need sudo or pkexec to start OpenFortiVPN."
    return 1
  fi

  if ! wait_for_port "$saml_port" 6000; then
    notify "VPN" "SAML listener not ready on port ${saml_port}."
    return 1
  fi

  if [[ -n "$url" ]]; then
    notify_action_open_url "$url" || notify "VPN" "Open login: $url"
  else
    notify "VPN" "SAML login URL not available."
  fi
}

disconnect_vpn() {
  if ! vpn_proc_running && ! vpn_iface_up && !(systemd_service_exists && systemd_is_active); then
    notify "VPN" "Already disconnected."
    return 0
  fi

  # If openfortivpn is running outside systemd, kill directly.
  if vpn_proc_running && !(systemd_service_exists && systemd_is_active); then
    notify "VPN" "Disconnecting (auth prompt may appear)..."
    if systemd_cleanup_exists; then
      systemd_cleanup_vpn || true
    else
      force_disconnect_root || true
    fi
    wait_for_disconnect 6000 || true
    if ! vpn_proc_running && ! vpn_iface_up; then
      notify "VPN" "Disconnected."
      return 0
    fi
    notify "VPN" "Disconnect failed; OpenFortiVPN still running."
    return 1
  fi

  if systemd_service_exists; then
    notify "VPN" "Disconnecting (auth prompt may appear)..."
    if ! systemd_stop_vpn; then
      notify "VPN" "Failed to stop OpenFortiVPN (check polkit prompt)."
      return 1
    fi
    if wait_for_disconnect 6000; then
      notify "VPN" "Disconnected."
      return 0
    fi
    if have_cmd systemctl; then
      systemctl kill --signal=SIGINT openfortivpn.service >/dev/null 2>&1 || true
    fi
    if wait_for_disconnect 4000; then
      notify "VPN" "Disconnected."
      return 0
    fi
    if systemd_cleanup_exists; then
      systemd_cleanup_vpn || true
    else
      force_disconnect_root || true
    fi
    if wait_for_disconnect 3000; then
      notify "VPN" "Disconnected."
      return 0
    fi
    notify "VPN" "Disconnect failed; OpenFortiVPN still running."
    return 1
  fi

  if have_cmd "$SUDO_CMD" && "$SUDO_CMD" -n true >/dev/null 2>&1; then
    "$SUDO_CMD" -n pkill -INT "$VPN_PROC_NAME" >/dev/null 2>&1 || true
    notify "VPN" "Disconnecting..."
    return 0
  fi

  if have_cmd pkexec; then
    run_background pkexec pkill -INT "$VPN_PROC_NAME"
    notify "VPN" "Disconnecting (polkit prompt may appear)..."
    return 0
  fi

  notify "VPN" "Need sudo or pkexec to disconnect."
}

toggle_vpn() {
  local state
  state="$(vpn_state)"
  if [[ "$state" == "connected" || "$state" == "connecting" || "$state" == "error" ]]; then
    disconnect_vpn
  else
    connect_vpn
  fi
}

case "${1:-status}" in
  status)
    status_json
    ;;
  connect)
    connect_vpn
    ;;
  disconnect)
    disconnect_vpn
    ;;
  toggle)
    toggle_vpn
    ;;
  *)
    echo "Usage: $0 {status|connect|disconnect|toggle}" >&2
    exit 2
    ;;
esac
